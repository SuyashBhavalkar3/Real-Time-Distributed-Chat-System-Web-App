# Chat Gateway Service

A stateless, scalable WebSocket gateway service for real-time message delivery in a distributed chat application. This service acts as the bridge between online users and the message broker (Kafka), enabling instant message fanout to connected clients.

## Overview

The Chat Gateway Service is responsible for:
- WebSocket Connection Management: Maintains persistent WebSocket connections with online users
- Real-time Message Delivery: Consumes messages from Kafka topics and sends them to connected users in real-time
- Stateless Architecture: Can be horizontally scaled without state persistence concerns
- User Session Tracking: Maps user IDs to their active WebSocket sessions

## Architecture

```
┌─────────────────────────────────────┐
│     Connected WebSocket Clients     │
│   (Users with Active Connections)   │
└────────────┬────────────────────────┘
             │ (WebSocket Protocol)
             ▼
┌─────────────────────────────────────┐
│    Chat Gateway Service (8081)      │
│  ┌───────────────────────────────┐  │
│  │ WebSocket Handler             │  │
│  │ - Connection Management       │  │
│  │ - Message Routing to Users    │  │
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ Kafka Consumer                │  │
│  │ - Listens to chat-messages    │  │
│  │ - Processes incoming events   │  │
│  └───────────────────────────────┘  │
└────────────┬────────────────────────┘
             │ (Kafka Protocol)
             ▼
┌─────────────────────────────────────┐
│  Kafka Broker (localhost:9092)      │
│  - Topic: chat-messages             │
│  - Consumer Group: websocket-group  │
└─────────────────────────────────────┘
```

## Prerequisites

- Java 21 LTS or higher
- Apache Kafka running on `localhost:9092`
- Maven 3.6+ for building
- Redis (optional, for future session management and caching)

## Installation & Setup

### 1. Clone/Access the Repository
```bash
cd chat-gateway-service
```

### 2. Build the Service
```bash
mvn clean package
```

### 3. Run with Maven
```bash
mvn spring-boot:run
```

Or run the compiled JAR:
```bash
java -jar target/chat-gateway-service-0.0.1-SNAPSHOT.jar
```

The service will start on port 8081.

## Configuration

Configuration is managed via `src/main/resources/application.yaml`:

```yaml
server:
  port: 8081                          # Service port

spring:
  application:
    name: chat-gateway-service
  kafka:
    bootstrap-servers: localhost:9092 # Kafka broker address
    consumer:
      group-id: websocket-group       # Consumer group ID
      auto-offset-reset: earliest     # Start from earliest message if no offset
      key-deserializer: StringDeserializer
      value-deserializer: StringDeserializer
  data:
    redis:
      host: localhost                 # Redis host (optional, for future use)
      port: 6379                      # Redis port (optional, for future use)
```

### Configuration Options

| Property | Default | Description |
|----------|---------|-------------|
| `server.port` | 8081 | Port where WebSocket service listens |
| `spring.kafka.bootstrap-servers` | localhost:9092 | Kafka broker connection string |
| `spring.kafka.consumer.group-id` | websocket-group | Kafka consumer group |
| `spring.kafka.consumer.auto-offset-reset` | earliest | Offset reset strategy |
| `spring.data.redis.host` | localhost | Redis host (optional, for future use) |
| `spring.data.redis.port` | 6379 | Redis port (optional, for future use) |

## WebSocket API

### Connection Endpoint
```
ws://localhost:8081/ws/chat?userId={userId}
```

#### Parameters
- `userId` (required): UUID of the user connecting (must be valid UUID v1 format)

#### Example
```
ws://localhost:8081/ws/chat?userId=22222222-2222-2222-2222-222222222222
```

### Message Format

Messages received from Kafka are forwarded as JSON:
```json
{
  "messageId": "12345678-1234-5678-1234-567812345678",
  "conversationId": "87654321-4321-8765-4321-876543218765",
  "senderId": "11111111-1111-1111-1111-111111111111",
  "recipientId": "22222222-2222-2222-2222-222222222222",
  "content": "Hello, this is a chat message",
  "createdAt": "2026-02-10T10:30:00Z"
}
```

## Testing

### Using wscat (WebSocket CLI)

Install wscat:
```bash
npm install -g wscat
```

Connect to the gateway:
```bash
wscat -c ws://localhost:8081/ws/chat?userId=22222222-2222-2222-2222-222222222222
```

### Sending Test Messages

1. Ensure the message-service is running on port 8080
2. Send a message via the message service REST API
3. The gateway will receive it from Kafka and deliver to connected users

### Using curl to Send a Test Message
```bash
curl -X POST http://localhost:8080/messages \
  -H "Content-Type: application/json" \
  -d '{
    "conversationId": "87654321-4321-8765-4321-876543218765",
    "messageId": "12345678-1234-5678-1234-567812345678",
    "senderId": "11111111-1111-1111-1111-111111111111",
    "recipientId": "22222222-2222-2222-2222-222222222222",
    "content": "Test message from REST API"
  }'
```

## Key Dependencies

| Dependency | Purpose |
|-----------|---------|
| `spring-boot-starter-web` | REST and web support |
| `spring-boot-starter-websocket` | WebSocket protocol support |
| `spring-kafka` | Kafka producer/consumer integration |
| `kafka-streams` | Stream processing capabilities |
| `jackson-databind` | JSON serialization/deserialization |
| `lombok` | Reduce boilerplate code |
| `spring-boot-starter-data-redis` | Redis integration (optional, for future use) |

## Project Structure

```
chat-gateway-service/
├── src/main/java/com/chat/gateway/
│   ├── ChatGatewayServiceApplication.java  # Entry point
│   ├── config/                             # Configuration classes
│   ├── consumer/                           # Kafka consumer logic
│   │   └── WebSocketKafkaConsumer.java     # Kafka listener for messages
│   ├── event/                              # Event models
│   │   └── MessageEvent.java               # Message event DTO
│   └── websocket/                          # WebSocket handlers
│       └── ChatWebSocketHandler.java       # WebSocket connection handler
├── src/main/resources/
│   └── application.yaml                    # Configuration file
├── pom.xml                                 # Maven dependencies
└── readme                                  # This file
```

## Message Flow

1. User connects to WebSocket endpoint with their userId
2. Gateway stores the mapping of userId → WebSocket session
3. Message Service receives message and publishes to Kafka `chat-messages` topic
4. Kafka Consumer in Gateway receives the message event
5. Gateway looks up the recipient's WebSocket session
6. Message is delivered to the recipient in real-time
7. Recipient receives the message via open WebSocket connection

## Kafka Topics

| Topic | Purpose | Consumer Group |
|-------|---------|----------------|
| `chat-messages` | All chat messages to be delivered to users | `websocket-group` |

## Notes & Best Practices

- Stateless Design: The gateway is stateless and can be scaled horizontally
- Connection Persistence: WebSocket connections are maintained on the server-side
- UUID Format: User IDs must be valid UUIDs (v1 format recommended)
- Message Delivery: Messages are delivered only to connected users; offline users won't receive them
- Consumer Group: Multiple gateway instances can use the same consumer group for load distribution
- Redis Integration: Redis is configured for potential future use in session management and caching, though not currently utilized

## Troubleshooting

### WebSocket Connection Refused
- Ensure the service is running on port 8081
- Check firewall settings
- Verify userId is a valid UUID

### Messages Not Being Received
- Ensure Kafka is running on `localhost:9092`
- Check that the message-service is publishing to the `chat-messages` topic
- Verify the consumer group is active with `kafka-consumer-groups` command

### Build Errors
- Use Java 21 LTS: `java --version`
- Clear Maven cache: `mvn clean install`
- Ensure all dependencies are downloaded

## License

This project is part of the Real-Time Distributed Chat System.

## Additional Testing

### Checking User Sessions in Redis

To verify user session management (if Redis is enabled):

1. Connect a user via WebSocket:
   ```bash
   wscat -c ws://localhost:8081/ws/chat?userId=12345678-1234-5678-1234-567812345678
   ```

2. Check Redis for the session:
   ```bash
   docker exec -it redis redis-cli
   ```

   Inside Redis CLI:
   ```redis
   keys *
   TTL user:12345678-1234-5678-1234-567812345678
   get user:12345678-1234-5678-1234-567812345678
   ```

   The TTL command should return an integer near 60, decreasing by 1 every second. This indicates the session TTL set to expire after 60 seconds of inactivity.

### Running Multiple Instances  
To test horizontal scalability, you can run multiple instances of the gateway service on different ports:
```bash
  cd chat-gateway-service
  mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8082 --gateway.instance-id=gateway-2"
  mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8083 --gateway.instance-id=gateway-3"
```

execute redis-cli in vs code terminal
docker exec -it redis redis-cli

get user:11111111-1111-1111-1111-111111111111
TTL user:11111111-1111-1111-1111-111111111111

get user:22222222-2222-2222-2222-222222222222
TTL user:22222222-2222-2222-2222-222222222222


Implemented Distributed websocket gateway with Kafka consumer for real-time message delivery. The gateway maintains WebSocket connections with online users and consumes messages from Kafka topics to deliver them in real-time. The service is stateless and can be horizontally scaled without state persistence concerns. User session tracking is implemented using Redis, allowing for efficient management of active WebSocket sessions.
API endpoint for sending messages to the gateway:
```bash
  {
    "messageId": "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa",
    "conversationId": "bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb",
    "senderId": "11111111-1111-1111-1111-111111111111",
    "recipientId": "22222222-2222-2222-2222-222222222222",
    "content": "Hello from A to B"
  }
  ```

  first we have to run the message service on port 8080, then we can send a message to the gateway using the above JSON payload. The gateway will consume the message from Kafka and deliver it to the recipient in real-time if they are connected via WebSocket.
  and then first connect userB to the gateway using WebSocket:

for userA, we can connect to the gateway using WebSocket:
  ```bash
  wscat -c ws://localhost:8081/ws/chat?userId=11111111-1111-1111-1111-111111111111
  ```

for userB, we can connect to the gateway using WebSocket:
  ```bash
  wscat -c ws://localhost:8082/ws/chat?userId=22222222-2222-2222-2222-222222222222
  ```


  Then send the message from the message service, and userB should receive it in real-time through the WebSocket connection.

  Added JackSon configuration to handle Java 21 date/time serialization and deserialization, ensuring compatibility with the new date/time API. This allows for proper handling of timestamps in message events without serialization issues.